\documentclass[11pt, a4paper]{article}

% --- UNIVERSAL PREAMBLE BLOCK ---
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=2cm, right=2cm]{geometry}
\usepackage{fontspec}
\usepackage[english, provide=*]{babel}

\babelprovide[import, onchar=ids fonts]{english}

% Set default/Latin font to Sans Serif in the main (rm) slot
\babelfont{rm}{Noto Sans}
\babelfont{sf}{Noto Sans}
\babelfont{tt}{Noto Sans Mono}


% Add because main language is not English (Standard Protocol) - though strictly English here, good for consistency
\usepackage{enumitem}
\setlist[itemize]{label=-}

% --- PACKAGES FOR THIS DOCUMENT ---
\usepackage{xcolor}
\usepackage{listings}
\usepackage{titlesec}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{caption}

% Hyperref must be loaded last
\usepackage[hidelinks]{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    pdftitle={Windows Server Deployment Guide on AWS Cloud}
}

% --- CODE LISTING CONFIGURATION ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single
}

\lstset{style=mystyle}

% --- DOCUMENT START ---
\title{\textbf{Windows Server Deployment Guide on AWS Cloud}}
% \author{Sou Chanrojame}
\author{Sou Chanrojame, Orn Pheakdey, Long Neron, Then Sivthean, Le Sreyma}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
	This document provides a comprehensive step-by-step guide for deploying various Windows Server roles and services on the AWS Cloud infrastructure, including configuration details for EC2 instances, security groups, and storage optimization.
\end{abstract}


\tableofcontents
\newpage

\phantomsection
\addcontentsline{toc}{section}{Prerequisites}
\section*{Prerequisites}

\subsection*{AWS Account Setup}
\begin{itemize}
	\item Active AWS account with appropriate permissions
	\item VPC configured with public and private subnets
	\item Security groups properly configured
	\item Key pairs created for RDP access
	\item IAM roles for EC2 instances
\end{itemize}

\subsection*{General Windows Server Launch Steps}
\begin{enumerate}
	\item Navigate to EC2 Dashboard in AWS Console
	\item Click ``Launch Instance''
	\item Select Windows Server AMI (2019/2022 recommended)
	\item Choose instance type based on workload
	\item Configure instance details (VPC, subnet, IAM role)
	\item Add storage as needed
	\item Configure security groups
	\item Review and launch with key pair
\end{enumerate}

% \hrule
\newpage

\section{File Server}

\subsection{AWS Configuration}
Instance Name: File Server\\
Instance Type: t3.medium or larger\\
Storage: EBS volumes with provisioned IOPS for performance\\
Security Group Ports: tcp 445 (SMB), tcp 3389 (RDP)

\subsection{Implementation}

\begin{lstlisting}[language=bash]
Install-WindowsFeature -Name FS-FileServer
New-Item -Path "C:\FileShare" -ItemType Directory -Force
New-SmbShare -Name "PublicShare" -Path "C:\FileShare" -FullAccess "Everyone"
echo hello > C:\FileShare\hello.txt
Write-Host "File Server setup complete."
\end{lstlisting}


\subsection{Usage}
\begin{itemize}
	\item connect to Proxy Server or other windows server
	\item open file explorer and \verb|\\<public dns of File Server>|
	\item enter credential
\end{itemize}

% \includegraphics[width=\textwidth]{static/file_server/demo.png}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{static/file_server/demo.png}
	\caption{Successfully connected to file server}
	\label{fig:file-server}
\end{figure}

\newpage

\section{Proxy Server (Caching, Control Access)}

\subsection{AWS Configuration}
Instance Name: Proxy Server\\
Instance Type: t3.medium\\
Security Group Ports: tcp 3128, tcp 3389 (RDP)

\subsection{Implementation}
\begin{lstlisting}[language=bash]
Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
choco install squid -y
Invoke-WebRequest https://raw.githubusercontent.com/james5635/windows_server_assignment/refs/heads/main/config/squid.conf -OutFile "C:\Squid\etc\squid\squid.conf"
Restart-Service squidsrv
Write-Host "Proxy Server setup complete."
\end{lstlisting}


\subsection{Usage}
\begin{itemize}
	\item connect to File Server or other windows server
	\item change proxy address to \verb|<private ip of Proxy Server>| with port 3128
	\item open browser
	\item visit youtube.com => allow
	\item visit facebook.com => blocked
\end{itemize}


\begin{figure}[htbp]
	\includegraphics[width=\textwidth]{static/proxy_server/allow_youtube.png}
	\caption{Allow access to youtube}

\end{figure}
\clearpage

\begin{figure}[htbp]
	\includegraphics[width=\textwidth]{static/proxy_server/block_facebook.png}
	\caption{Block access to facebook}
\end{figure}

\clearpage

\section{DNS Server}

\subsection{AWS Configuration}
Instance Name: DNS Server\\
Instance Type: t3.medium\\
Security Group Ports: tcp/udp 53, tcp 3389 (RDP)

\subsection{Implementation}
\begin{lstlisting}[language=bash]
Install-WindowsFeature DNS -IncludeManagementTools

Add-DnsServerPrimaryZone -Name "example.internal" -ZoneFile "example.internal.dns"
Add-DnsServerPrimaryZone -Name "devspeed.com" -ZoneFile "devspeed.com.dns"

Add-DnsServerResourceRecordA -Name 'server1' -ZoneName 'example.internal' -IPv4Address '10.0.1.10'
Add-DnsServerResourceRecordA -Name 'console' -ZoneName 'devspeed.com' -IPv4Address '192.168.1.11'
Add-DnsServerResourceRecordA -Name 'go' -ZoneName 'devspeed.com' -IPv4Address '192.168.1.29'
Add-DnsServerResourceRecordA -Name 'blog' -ZoneName 'devspeed.com' -IPv4Address '192.168.1.30'
Add-DnsServerResourceRecordA -Name 'shop' -ZoneName 'devspeed.com' -IPv4Address '192.168.1.31'
Add-DnsServerResourceRecordA -Name 'support' -ZoneName 'devspeed.com' -IPv4Address '192.168.1.32'
Add-DnsServerResourceRecordA -Name 'mail' -ZoneName 'devspeed.com' -IPv4Address '192.168.1.33'
Add-DnsServerResourceRecordA -Name 'www' -ZoneName 'devspeed.com' -IPv4Address '192.168.1.34'
Add-DnsServerResourceRecordA -Name 'www2' -ZoneName 'devspeed.com' -IPv4Address '192.168.1.100'

# For example, forwarding to Google DNS:
# Add-DnsServerForwarder -IPAddress "8.8.8.8" -PassThru
# Or forwarding to AWS VPC DNS (recommended for EC2). This is the Amazon-provided DNS resolver for VPCs.
# Add-DnsServerForwarder -IPAddress "169.254.169.253" -PassThru

New-NetFirewallRule -DisplayName "Allow DNS TCP 53" -Direction Inbound -Protocol TCP -LocalPort 53 -Action Allow
New-NetFirewallRule -DisplayName "Allow DNS UDP 53" -Direction Inbound -Protocol UDP -LocalPort 53 -Action Allow

\end{lstlisting}



\subsection{Usage}
\begin{itemize}
	\item open Terminal
	\item dog www.devspeed.com `@<public ip of dns server>`
	\item dog go.devspeed.com `@<public ip of dns server>`
	\item nslookup shop.devspeed.com `<public ip of dns server>`
	\item nslookup mail.devspeed.com `<public ip of dns server>`
\end{itemize}
\clearpage
\begin{figure}[htbp]
	\includegraphics[width=\textwidth]{static/dns_server/connect_dns_server.png}
	\caption{Dns server response with respective IP address}
\end{figure}

\clearpage

\section{DHCP Server}

\subsection{AWS Configuration}
\textbf{Instance Type:} t3.small\\
\textbf{Note:} AWS VPC provides DHCP by default; custom DHCP server is optional.

\subsection{Implementation Steps}

\begin{enumerate}
	\item \textbf{Launch Windows Server Instance}

	\item \textbf{Install DHCP Server Role}
	      \begin{lstlisting}[language=bash]
Install-WindowsFeature -Name DHCP -IncludeManagementTools
Add-DhcpServerInDC -DnsName "dhcp.yourdomain.local"
\end{lstlisting}

	\item \textbf{Configure DHCP Scope}
	      \begin{lstlisting}[language=bash]
Add-DhcpServerv4Scope -Name "Internal Network" -StartRange 10.0.1.100 -EndRange 10.0.1.200 -SubnetMask 255.255.255.0

Set-DhcpServerv4OptionValue -ScopeId 10.0.1.0 -Router 10.0.1.1
Set-DhcpServerv4OptionValue -ScopeId 10.0.1.0 -DnsServer 10.0.1.10
\end{lstlisting}

	\item \textbf{Configure Reservations}
	      \begin{lstlisting}[language=bash]
Add-DhcpServerv4Reservation -ScopeId 10.0.1.0 -IPAddress 10.0.1.50 -ClientId "00-11-22-33-44-55" -Description "Print Server"
\end{lstlisting}

	\item \textbf{Authorize DHCP Server}
	      \begin{lstlisting}[language=bash]
Add-DhcpServerInDC -DnsName "dhcp.yourdomain.local" -IPAddress 10.0.1.10
\end{lstlisting}
\end{enumerate}

\subsection{Best Practices}
\begin{itemize}
	\item Consider using AWS-provided DHCP for simplicity
	\item Deploy DHCP failover for redundancy
	\item Use DHCP policies for different device types
	\item Monitor DHCP lease utilization
\end{itemize}

\newpage

\section{VPN Server}

\subsection{AWS Configuration}
Instance Name: VPN Server\\
Instance Type: t3.small to t3.medium\\
Security Group Ports: udp 1194, tcp 3389 (RDP)\\
Elastic IP: Required for consistent endpoint

\subsection{Implementation}

\begin{lstlisting}[language=bash]

Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
choco install openvpn -y  --package-parameters=" /AddToDesktop /Gui /GuiOnLogon /EasyRsa /DcoDriver /TapDriver /WintunDriver /OpenSSL /Service "
choco install caddy 7zip -y

$cfg = "C:\Program Files\OpenVPN\config"

Invoke-WebRequest https://raw.githubusercontent.com/james5635/windows_server_assignment/refs/heads/main/config/openvpn/server/dh.pem -OutFile "$cfg\dh.pem"
Invoke-WebRequest https://raw.githubusercontent.com/james5635/windows_server_assignment/refs/heads/main/config/openvpn/server/server.crt -OutFile "$cfg\server.crt"
Invoke-WebRequest https://raw.githubusercontent.com/james5635/windows_server_assignment/refs/heads/main/config/openvpn/server/server.key -OutFile "$cfg\server.key"
Invoke-WebRequest https://raw.githubusercontent.com/james5635/windows_server_assignment/refs/heads/main/config/openvpn/server/ca.crt -OutFile "$cfg\ca.crt"
Invoke-WebRequest https://raw.githubusercontent.com/james5635/windows_server_assignment/refs/heads/main/config/openvpn/server/server.ovpn -OutFile "$cfg\server.ovpn"

Set-Service -Name OpenVPNService -StartupType Automatic
Start-Service -Name OpenVPNService

New-NetFirewallRule -DisplayName "OpenVPN" -Direction Inbound -Protocol UDP -LocalPort 1194 -Action Allow
New-NetFirewallRule -DisplayName "ShareFileOpenVPN" -Direction Inbound -Protocol TCP -LocalPort 80 -Action Allow

# don't know why it doesn't working. (The server doesn't run)
# sleep -Seconds 5 # still not working
# Start-Process "C:\Program Files\OpenVPN\bin\openvpn-gui.exe"

# # for client to openvpn server
# $cfg = "C:\Program Files\OpenVPN\config"
# Invoke-WebRequest <url> "$cfg\client1.ovpn"
# Invoke-WebRequest <url> "$cfg\ca.crt"
# Invoke-WebRequest <url> "$cfg\client1.crt"
# Invoke-WebRequest <url> "$cfg\client1.key"

\end{lstlisting}

\subsection{Usage}
\begin{itemize}
	\item connect to VPN Server
	\item Open \verb|OpenVPN GUI| to start the server
	\item connect to File Server
	\item change \verb|YOUR_PUBLIC_IP| in \verb|C:\Program Files\OpenVPN\config\client1.ovpn| \\
	      to public ip of the VPN Server
	\item Open \verb|OpenVPN GUI| to connect to the server
	\item Open powershell and type \verb|ipconfig| and will see something like:

	      \begin{lstlisting}{language=bash}
Unknown adapter OpenVPN Data Channel Offload:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::f729:5f67:58f2:7253%17
   IPv4 Address. . . . . . . . . . . : 10.8.0.6
   Subnet Mask . . . . . . . . . . . : 255.255.255.252
   Default Gateway . . . . . . . . . :
\end{lstlisting}

\end{itemize}

\begin{figure}[htbp]
	\includegraphics[width=\textwidth]{static/vpn_server/connect_vpn_server.png}
	\caption{vpn client successfully connect to VPN server}
\end{figure}

\newpage

\section{Terminal Server (Thin Clients)}

\subsection{AWS Configuration}
Instance Name: Terminal Server\\
Instance Type: t3.medium\\
Security Group Ports: tcp 3389 (RDP)

\subsection{Implementation}

\begin{lstlisting}[language=bash]
# Install Remote Desktop Session Host Role
Install-WindowsFeature RDS-RD-Server
# Enable Multiple Sessions
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server" -Name fSingleSessionPerUser -Value 0
# Allow RDP Firewall Rule
Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
Write-Host "Terminal Server (RDS Session Host) setup complete."
\end{lstlisting}

\subsection{Usage}
\begin{itemize}
	\item connect to the server with RDP
\end{itemize}

\begin{figure}[htbp]
	\includegraphics[width=\textwidth]{static/terminal_server/connect_terminal_server.png}
	\caption{Successfully connect to terminal server}
\end{figure}

\newpage

\section{Web Server}

\subsection{AWS Configuration}
Instance Name: Web Server\\
Instance Type: t3.medium\\
Security Group Ports: tcp 80 (HTTP), tcp 443 (HTTPS), tcp 3389 (RDP)\\

\subsection{Implementation}

\begin{lstlisting}{language=bash}
Install-WindowsFeature -Name Web-Server -IncludeManagementTools
# Install-WindowsFeature -Name Web-Asp-Net45, Web-Net-Ext45
# Install-WindowsFeature -Name Web-Mgmt-Console
Invoke-WebRequest https://raw.githubusercontent.com/james5635/windows_server_assignment/refs/heads/main/static/devspeed.html -OutFile "C:\inetpub\wwwroot\index.html"
\end{lstlisting}

\subsection{Usage}
\begin{itemize}
	\item visit public dns of the server
\end{itemize}

\begin{figure}[htbp]
	\includegraphics[width=\textwidth]{static/web_server/connect_web_server.png}
	\caption{visiting the web page}
\end{figure}

\newpage

\section{Mail Server}

\subsection{AWS Configuration}
\textbf{Instance Type:} t3.medium\\
\textbf{Security Group Ports:} 25 (SMTP), 110 (POP3), 143 (IMAP), 587 (Submission), 993 (IMAPS), 995 (POP3S)\\
\textbf{Elastic IP:} Required\\
\textbf{Note:} AWS blocks port 25 by default; request removal.

\subsection{Implementation}

\begin{lstlisting}[language=bash]
# mail server
# - apache james (smpt server [port: 25], imap server [port: 143])
# - swaks (smpt client)
# - thunderbird (email client)

Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
choco install openjdk strawberryperl thunderbird notepadplusplus telnet -y
Invoke-WebRequest https://www.jetmore.org/john/code/swaks/files/swaks-20240103.0/swaks -OutFile swaks.pl
Invoke-WebRequest https://dlcdn.apache.org/james/server/3.9.0/james-server-spring-app-3.9.0-app.zip -OutFile james-server-spring-app-3.9.0-app.zip
Expand-Archive james-server-spring-app-3.9.0-app.zip -DestinationPath james-server-spring-app-3.9.0-app

Invoke-WebRequest https://raw.githubusercontent.com/james5635/windows_server_assignment/refs/heads/main/config/smtpserver.xml -OutFile "james-server-spring-app-3.9.0-app\james-server-spring-app-3.9.0\conf\smtpserver.xml"
Invoke-WebRequest https://raw.githubusercontent.com/james5635/windows_server_assignment/refs/heads/main/config/imapserver.xml -OutFile "james-server-spring-app-3.9.0-app\james-server-spring-app-3.9.0\conf\imapserver.xml"

Import-Module $env:ChocolateyInstall\helpers\chocolateyProfile.psm1
refreshenv

# cd "james-server-spring-app-3.9.0-app\james-server-spring-app-3.9.0\bin\"

$james = "C:\Windows\System32\james-server-spring-app-3.9.0-app\james-server-spring-app-3.9.0\bin\james.bat"
$james_cli = "C:\Windows\System32\james-server-spring-app-3.9.0-app\james-server-spring-app-3.9.0\bin\james-cli.ps1"

Invoke-WebRequest https://raw.githubusercontent.com/james5635/windows_server_assignment/refs/heads/main/scripts/james-cli.ps1 -OutFile $james_cli

function Wait-JamesReady {
    param(
        [int]$Port = 9999,
        [string]$Url = "localhost",
        [int]$TimeoutSeconds = 120
    )

    $start = Get-Date

    Write-Host "Waiting for James server to open JMX on port $Port..."

    while ((Get-Date) -lt $start.AddSeconds($TimeoutSeconds)) {
        if ((Test-NetConnection -ComputerName $Url -Port $Port -WarningAction SilentlyContinue).TcpTestSucceeded) {
            Write-Host "James server is ready!"
            return
        }

        Start-Sleep -Seconds 2
    }

    throw "Timeout: James server did not open JMX port $Port"
}

& $james install
& $james start

# need to wait james server completely ready
Wait-JamesReady

& $james_cli -username james-admin -password changeme adddomain example.local
& $james_cli -username james-admin -password changeme adduser mike@example.local mike
& $james_cli -username james-admin -password changeme adduser joe@example.local joe
& $james_cli -username james-admin -password changeme adduser leng@example.local leng
& $james_cli -username james-admin -password changeme adduser jame@example.local jame

New-NetFirewallRule -DisplayName "Allow smtp 25" -Direction Inbound -Protocol TCP -LocalPort 25 -Action Allow
New-NetFirewallRule -DisplayName "Allow imap 143" -Direction Inbound -Protocol TCP -LocalPort 143 -Action Allow

\end{lstlisting}

\subsection{Usage}
\begin{itemize}
	\item Open Thunderbird
	\item Username: \texttt{jame@example.local}
	\item Password: \texttt{jame}
	\item Username: \texttt{mike@example.local}
	\item Password: \texttt{mike}

	\item IMAP
	      \begin{itemize}
		      \item Hostname: \texttt{<public-ip-of-mail-server>}
		      \item Port: 143
	      \end{itemize}

	\item SMTP
	      \begin{itemize}
		      \item Hostname: \texttt{<public-ip-of-mail-server>}
		      \item Port: 25
	      \end{itemize}
\end{itemize}

\clearpage
\begin{figure}[htbp]
	\includegraphics[width=\textwidth]{static/mail_server/connect_mail_server.png}
	\caption{Two users sending messages to each other}
\end{figure}

\clearpage

\section{Database Server}

\subsection{AWS Configuration}
Instance Name: Database Server\\
Instance Type: t3.medium or larger (memory-optimized)\\
Storage: EBS with provisioned IOPS or io2\\
Security Group Ports:
\begin{itemize}
	\item PostgreSQL: tcp 5432
	\item SQL Server: tcp 1433
	\item MongoDB: tcp 27017
	\item RDP: tcp 3389
\end{itemize}

\subsection{Implementation}

\subsubsection{PostgreSQL}

\begin{lstlisting}[language=bash]
 # postgresql
 Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
 # username postgres
 choco install postgresql11 --params '/Password:test /AllowRemote' -y
 Restart-Service postgresql-x64-11
 New-NetFirewallRule -DisplayName "Allow PostgreSQL 5432" `
   -Direction Inbound `
   -Protocol TCP `
   -LocalPort 5432 `
   -Action Allow
\end{lstlisting}

\subsubsection{SQL Server}
 \begin{lstlisting}[language=bash]
 # sql server
 Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
 choco install mssqlserver2014express -y
 choco install sqlserver-cmdlineutils -y

 # Get access to SqlWmiManagement DLL on the machine with SQL
 # we are on, which is where SQL Server was installed.
 # Note: This is installed in the GAC by SQL Server Setup.

 # Load the WMI assembly
 [System.Reflection.Assembly]::LoadWithPartialName('Microsoft.SqlServer.SqlWmiManagement') | Out-Null

 # Connect to local SQL Server machine
 $wmi = New-Object 'Microsoft.SqlServer.Management.Smo.Wmi.ManagedComputer' 'localhost'

 # Get TCP protocol for SQLEXPRESS
 $tcp = $wmi.ServerInstances['SQLEXPRESS'].ServerProtocols['Tcp']
 $tcp.IsEnabled = $true

 # Disable dynamic ports on each IP entry
 foreach ($ip in $tcp.IPAddresses) {
     $ip.IPAddressProperties["TcpDynamicPorts"].Value = ""
 }

 # Set static port 1433 on ALL IPs (including IPAll)
 foreach ($ip in $tcp.IPAddresses) {
     $ip.IPAddressProperties["TcpPort"].Value = "1433"
 }

 # Apply configuration
 $tcp.Alter()

 # You need to restart SQL Server for the change to persist
 # -Force takes care of any dependent services, like SQL Agent.
 # Note: If the instance is named, replace MSSQLSERVER with MSSQL$ followed by
 # the name of the instance (e.g., MSSQL$MYINSTANCE)

 Restart-Service -Name 'MSSQL$SQLEXPRESS' -Force

 & "C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\110\Tools\Binn\SQLCMD.EXE"  -S .\SQLEXPRESS -Q "ALTER LOGIN sa ENABLE; ALTER LOGIN sa WITH PASSWORD = 'mypassword@2025';"
 Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\MSSQL12.SQLEXPRESS\MSSQLServer" -Name LoginMode -Value 2
 Restart-Service -Name 'MSSQL$SQLEXPRESS' -Force

 New-NetFirewallRule -DisplayName "Allow SQL Server 1433" `
   -Direction Inbound `
   -Protocol TCP `
   -LocalPort 1433 `
   -Action Allow

\end{lstlisting}
\subsubsection{MongoDB}
 \begin{lstlisting}[language=bash]
 # mongodb
 Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
 choco install mongodb -y
 choco install mongodb-shell -y
 Invoke-WebRequest https://raw.githubusercontent.com/james5635/windows_server_assignment/refs/heads/main/config/mongod.cfg -OutFile "C:\Program Files\MongoDB\Server\8.2\bin\mongod.cfg"
 Restart-Service MongoDB
 New-NetFirewallRule -DisplayName "Allow MongoDB 27017" `
   -Direction Inbound `
   -Protocol TCP `
   -LocalPort 27017 `
   -Action Allow
\end{lstlisting}

\subsection{Usage}
\begin{itemize}
\item MongoDB
\begin{itemize}
  \item mongosh \texttt{<public ip of mongodb server>}
\end{itemize}
\item SQL Server
\begin{itemize}
\item /opt/mssql-tools18/bin/sqlcmd -S \texttt{<public ip of sql server>} -C -U sa -P mypassword@2025
\end{itemize}
\item PostgreSQL
\begin{itemize}
  \item psql -h \texttt{<public ip of postgresql server>} -U postgres
  \item password: test
\end{itemize}
\end{itemize}

\begin{figure}[htbp]
	\includegraphics[width=\textwidth]{static/database_server/postgresql.png}
	\caption{Client using postgresql server}
\end{figure}

\begin{figure}[htbp]
	\includegraphics[width=\textwidth]{static/database_server/sql_server.png}
	\caption{client using sql server}
\end{figure}
\clearpage
\begin{figure}[htbp]
	\includegraphics[width=\textwidth]{static/database_server/mongodb.png}
	\caption{client using mongodb server}
\end{figure}

\clearpage

\section{Backup Server}

\subsection{AWS Configuration}
\textbf{Instance Type:} t3.medium\\
\textbf{Storage:} Large EBS volumes or S3 integration\\
\textbf{IAM Role:} Permissions for S3, EBS snapshots

\subsection{Implementation Steps}

\begin{enumerate}
	\item \textbf{Launch Windows Server Instance}

	\item \textbf{Install Windows Server Backup}
	      \begin{lstlisting}[language=bash]
Install-WindowsFeature -Name Windows-Server-Backup -IncludeManagementTools
\end{lstlisting}

	\item \textbf{Configure AWS Backup}
	      \begin{itemize}
		      \item Set up AWS Backup service
		      \item Create backup plans
		      \item Assign resources to backup plans
	      \end{itemize}

	\item \textbf{Install Third-Party Backup Software}
	      \begin{itemize}
		      \item \textbf{Option A: Veeam Backup}\\
		            Download Veeam Backup \& Replication; Install and configure; Set up backup jobs to S3.
		      \item \textbf{Option B: Windows Server Backup to S3}
	      \end{itemize}
	      \begin{lstlisting}[language=bash]
# Create backup policy
$Policy = New-WBPolicy
$Target = New-WBBackupTarget -VolumePath "D:"
Add-WBBackupTarget -Policy $Policy -Target $Target
Add-WBVolume -Policy $Policy -Volume (Get-WBVolume -VolumePath "C:")
Set-WBSchedule -Policy $Policy -Schedule 02:00
Set-WBPolicy -Policy $Policy
\end{lstlisting}

	\item \textbf{Configure S3 Lifecycle Policies}
	      \begin{itemize}
		      \item Transition to S3 Glacier for long-term retention
		      \item Set expiration policies
	      \end{itemize}

	\item \textbf{Set Up EBS Snapshot Automation}
	      \begin{lstlisting}[language=bash]
# Using AWS PowerShell
New-EC2Snapshot -VolumeId vol-12345678 -Description "Daily Backup"
\end{lstlisting}
\end{enumerate}

\subsection{Best Practices}
\begin{itemize}
	\item Use AWS Backup for centralized backup management
	\item Store backups in S3 with versioning enabled
	\item Implement 3-2-1 backup strategy
	\item Test backup restoration regularly
	\item Use S3 Glacier for long-term archival
	\item Enable cross-region backup replication
\end{itemize}

\newpage

\section{Load Balancing}

\subsection{AWS Configuration}
\textbf{Service:} Application Load Balancer (ALB) or Network Load Balancer (NLB)\\
\textbf{Target Group:} Multiple Windows Server instances

\subsection{Implementation Steps}

\begin{enumerate}
	\item \textbf{Launch Multiple Windows Server Instances}
	      \begin{itemize}
		      \item Deploy identical servers in different availability zones
		      \item Install and configure web application on all instances
	      \end{itemize}

	\item \textbf{Create Target Group}
	      \begin{itemize}
		      \item Navigate to EC2 > Target Groups
		      \item Create target group with health check settings
	      \end{itemize}
	      \begin{verbatim}
Protocol: HTTP/HTTPS
Port: 80/443
Health Check Path: /health
Health Check Interval: 30 seconds
Healthy Threshold: 2
Unhealthy Threshold: 2
\end{verbatim}

	\item \textbf{Create Application Load Balancer}
	      \begin{itemize}
		      \item Choose ALB for HTTP/HTTPS traffic
		      \item Select availability zones
		      \item Configure security groups
		      \item Add listener rules
		      \item Register target group
	      \end{itemize}

	\item \textbf{Configure Session Persistence}
	      \begin{itemize}
		      \item Enable sticky sessions if needed
		      \item Configure duration
	      \end{itemize}

	\item \textbf{Set Up Auto Scaling Group}
	      \begin{lstlisting}[language=bash]
# Using AWS CLI or CloudFormation
# Define launch template
# Create auto-scaling group
# Configure scaling policies
\end{lstlisting}

	\item \textbf{Install and Configure IIS ARR (Alternative)}
	      \begin{lstlisting}[language=bash]
# For Windows-based load balancing
Install-WindowsFeature Web-Server -IncludeManagementTools
# Install Application Request Routing
# Configure server farms
\end{lstlisting}
\end{enumerate}

\subsection{Best Practices}
\begin{itemize}
	\item Use ALB for HTTP/HTTPS traffic
	\item Use NLB for TCP/UDP traffic or ultra-low latency
	\item Deploy instances across multiple availability zones
	\item Configure proper health checks
	\item Enable access logs for troubleshooting
	\item Use CloudWatch for monitoring
	\item Implement auto-scaling based on metrics
\end{itemize}

\newpage

\section{Failover Cluster}

\subsection{AWS Configuration}
\textbf{Instance Type:} r5.xlarge or larger\\
\textbf{Storage:} Shared storage using FSx for Windows or S3\\
\textbf{Network:} Placement groups for low latency\\
\textbf{Security Group:} Allow cluster communication ports

\subsection{Implementation Steps}

\begin{enumerate}
	\item \textbf{Launch Multiple Windows Server Instances}
	      \begin{itemize}
		      \item Deploy in same VPC, different availability zones
		      \item Use placement group for low latency
	      \end{itemize}

	\item \textbf{Install Failover Clustering Feature}
	      \begin{lstlisting}[language=bash]
Install-WindowsFeature -Name Failover-Clustering -IncludeManagementTools
\end{lstlisting}

	\item \textbf{Configure Shared Storage}
	      \begin{itemize}
		      \item \textbf{Option A: Amazon FSx for Windows File Server}\\
		            Create FSx file system; Mount on all cluster nodes.
		      \item \textbf{Option B: EBS Multi-Attach (io2 only)}\\
		            Attach same EBS volume to multiple instances; Initialize as cluster shared volume.
	      \end{itemize}

	\item \textbf{Create Failover Cluster}
	      \begin{lstlisting}[language=bash]
# Validate cluster configuration
Test-Cluster -Node "Node1", "Node2"

# Create cluster
New-Cluster -Name "MyCluster" -Node "Node1", "Node2" -StaticAddress "10.0.1.100" -NoStorage
\end{lstlisting}

	\item \textbf{Configure Cluster Quorum}
	      \begin{lstlisting}[language=bash]
Set-ClusterQuorum -NodeAndFileShareMajority "\\FSx\Witness"
\end{lstlisting}

	\item \textbf{Add Clustered Role}
	      \begin{lstlisting}[language=bash]
# For SQL Server
Add-ClusterServerRole -Name "SQL-Cluster" -Storage "Cluster Disk 1"
\end{lstlisting}

	\item \textbf{Configure Secondary Private IP}
	      \begin{itemize}
		      \item Assign secondary private IP to ENI
		      \item Configure in cluster as virtual IP
	      \end{itemize}
\end{enumerate}

\subsection{Common Cluster Types in AWS}
\begin{description}
	\item[SQL Server Failover Cluster] Use FSx for shared storage; Configure SQL Server on cluster nodes; Set up availability group for database replication.
	\item[File Server Cluster] Use FSx or S3 for storage; Configure highly available file shares.
\end{description}

\subsection{Best Practices}
\begin{itemize}
	\item Use Amazon FSx for Windows File Server for shared storage
	\item Deploy cluster nodes in different availability zones
	\item Use Elastic IP or Network Load Balancer for client access
	\item Monitor cluster health with CloudWatch
	\item Regular testing of failover scenarios
	\item Consider Amazon RDS Multi-AZ for database clustering
\end{itemize}

\newpage

\section{FTP Server}

\subsection{AWS Configuration}
\textbf{Instance Type:} t3.small to t3.medium\\
\textbf{Security Group Ports:} 21 (FTP Control), 20 (FTP Data), 990 (FTPS), Range for Passive Mode (e.g., 50000-50100)\\
\textbf{Elastic IP:} Required for consistent access

\subsection{Implementation Steps}

\begin{enumerate}
	\item \textbf{Launch Windows Server Instance with Elastic IP}

	\item \textbf{Install FTP Server Role}
	      \begin{lstlisting}[language=bash]
Install-WindowsFeature -Name Web-Ftp-Server -IncludeManagementTools
Install-WindowsFeature -Name Web-Ftp-Service
\end{lstlisting}

	\item \textbf{Configure FTP Site}
	      \begin{lstlisting}[language=bash]
# Create FTP site
New-WebFtpSite -Name "FTP Site" -Port 21 -PhysicalPath "D:\FTP"

# Configure authentication
Set-WebConfigurationProperty -Filter /system.ftpServer/security/authentication/basicAuthentication -PSPath IIS:\ -Location "FTP Site" -Name enabled -Value $true
\end{lstlisting}

	\item \textbf{Configure Passive Mode}
	      \begin{lstlisting}[language=bash]
# Set passive port range
Set-WebConfigurationProperty -Filter /system.ftpServer/firewallSupport -PSPath IIS:\ -Name lowDataChannelPort -Value 50000
Set-WebConfigurationProperty -Filter /system.ftpServer/firewallSupport -PSPath IIS:\ -Name highDataChannelPort -Value 50100

# Set external IP
Set-WebConfigurationProperty -Filter /system.ftpServer/firewallSupport -PSPath IIS:\ -Name externalIp4Address -Value "YOUR_ELASTIC_IP"
\end{lstlisting}

	\item \textbf{Enable FTPS (FTP over SSL)}
	      \begin{lstlisting}[language=bash]
# Import SSL certificate
$cert = New-SelfSignedCertificate -DnsName "ftp.yourdomain.com" -CertStoreLocation cert:\LocalMachine\My

# Bind certificate to FTP site
Set-WebConfigurationProperty -Filter /system.ftpServer/security/ssl -PSPath IIS:\ -Location "FTP Site" -Name serverCertHash -Value $cert.Thumbprint
Set-WebConfigurationProperty -Filter /system.ftpServer/security/ssl -PSPath IIS:\ -Location "FTP Site" -Name ssl128 -Value $true
\end{lstlisting}

	\item \textbf{Configure User Access}
	      \begin{lstlisting}[language=bash]
# Create FTP user
New-LocalUser -Name "ftpuser" -Password (ConvertTo-SecureString "Password123!" -AsPlainText -Force)

# Set folder permissions
$acl = Get-Acl "D:\FTP"
$permission = "ftpuser","FullControl","Allow"
$accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission
$acl.SetAccessRule($accessRule)
Set-Acl "D:\FTP" $acl
\end{lstlisting}

	\item \textbf{Configure Security Group}
	      \begin{itemize}
		      \item Allow port 21 (control)
		      \item Allow passive port range (50000-50100)
		      \item Restrict source IPs if possible
	      \end{itemize}
\end{enumerate}

\subsection{Alternative: AWS Transfer Family}
Consider using AWS Transfer Family (SFTP, FTPS, FTP) for fully managed file transfer service with S3 backend.

\subsection{Best Practices}
\begin{itemize}
	\item Use FTPS or SFTP instead of plain FTP
	\item Use AWS Transfer Family for managed solution
	\item Store files on S3 via AWS Transfer Family
	\item Limit source IP addresses in security groups
	\item Use separate EBS volume for FTP data
	\item Monitor with CloudWatch logs
	\item Regular security audits
\end{itemize}

\newpage

\section{Container (Docker)}

\subsection{AWS Configuration}
\textbf{Instance Type:} t3.medium or larger\\
\textbf{Operating System:} Windows Server 2019/2022 with Containers\\
\textbf{Security Group Ports:} Custom ports based on containerized applications

\subsection{Implementation Steps}

\begin{enumerate}
	\item \textbf{Launch Windows Server Instance}
	      \begin{itemize}
		      \item Choose Windows Server 2019/2022
		      \item Select version with container support
	      \end{itemize}

	\item \textbf{Install Docker}
	      \begin{lstlisting}[language=bash]
# Install Docker provider
Install-Module -Name DockerMsftProvider -Repository PSGallery -Force

# Install Docker
Install-Package -Name docker -ProviderName DockerMsftProvider -Force

# Restart computer
Restart-Computer -Force
\end{lstlisting}

	\item \textbf{Verify Docker Installation}
	      \begin{lstlisting}[language=bash]
docker version
docker info
\end{lstlisting}

	\item \textbf{Pull Windows Container Images}
	      \begin{lstlisting}[language=bash]
# Pull Windows Server Core base image
docker pull mcr.microsoft.com/windows/servercore:ltsc2022

# Pull .NET Framework image
docker pull mcr.microsoft.com/dotnet/framework/aspnet:4.8
\end{lstlisting}

	\item \textbf{Create Dockerfile}
	      \begin{lstlisting}[language=bash]
FROM mcr.microsoft.com/dotnet/framework/aspnet:4.8
WORKDIR /inetpub/wwwroot
COPY ./app .
EXPOSE 80
\end{lstlisting}

	\item \textbf{Build and Run Container}
	      \begin{lstlisting}[language=bash]
# Build image
docker build -t mywebapp:v1 .

# Run container
docker run -d -p 80:80 --name webapp mywebapp:v1

# View running containers
docker ps
\end{lstlisting}

	\item \textbf{Push to Amazon ECR}
	      \begin{lstlisting}[language=bash]
# Authenticate to ECR
aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com

# Tag image
docker tag mywebapp:v1 ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/mywebapp:v1

# Push image
docker push ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/mywebapp:v1
\end{lstlisting}
\end{enumerate}

\subsection{Alternative: Amazon ECS for Windows Containers}
Use Amazon Elastic Container Service (ECS) or Amazon Elastic Kubernetes Service (EKS) with Windows support for orchestrated container deployments.

\subsubsection{ECS Windows Container Setup}
\begin{enumerate}
	\item \textbf{Create ECS Cluster}
	      \begin{itemize}
		      \item Choose EC2 launch type with Windows AMI
		      \item Or use Fargate for Windows (when available)
	      \end{itemize}

	\item \textbf{Create Task Definition}
	      \begin{lstlisting}[language=bash]
{
  "family": "windows-webapp",
  "containerDefinitions": [
    {
      "name": "webapp",
      "image": "ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/mywebapp:v1",
      "memory": 2048,
      "cpu": 1024,
      "portMappings": [
        {
          "containerPort": 80,
          "protocol": "tcp"
        }
      ]
    }
  ],
  "requiresCompatibilities": ["EC2"],
  "networkMode": "awsvpc",
  "runtimePlatform": {
    "operatingSystemFamily": "WINDOWS_SERVER_2022_CORE"
  }
}
\end{lstlisting}

	\item \textbf{Create ECS Service}
	      \begin{itemize}
		      \item Deploy task definition
		      \item Configure load balancer
		      \item Set desired task count
	      \end{itemize}
\end{enumerate}

\subsection{Best Practices}
\begin{itemize}
	\item Use Amazon ECS or EKS for production container orchestration
	\item Store images in Amazon ECR
	\item Use Windows Server Core or Nano Server base images
	\item Implement CI/CD with AWS CodePipeline
	\item Monitor containers with CloudWatch Container Insights
	\item Use Task roles for AWS service access
	\item Regular image security scanning
\end{itemize}

\newpage

\section{Domain Controller}

\subsection{AWS Configuration}
\textbf{Instance Type:} t3.medium or larger\\
\textbf{Security Group Ports:}
\begin{itemize}
	\item 53 (DNS TCP/UDP)
	\item 88 (Kerberos)
	\item 135 (RPC)
	\item 139, 445 (SMB)
	\item 389, 636 (LDAP, LDAPS)
	\item 3268, 3269 (Global Catalog)
	\item 49152-65535 (Dynamic RPC)
\end{itemize}
\textbf{Storage:} Minimum 50GB SSD\\
\textbf{Operating System:} Windows Server 2019/2022

\subsection{Installation Steps}

\begin{enumerate}
	\item \textbf{Prepare the Server}
	      \begin{itemize}
		      \item Set a static IP address in Windows network settings
		      \item Configure DNS to point to itself (127.0.0.1) and a secondary DNS
		      \item Rename the server with a descriptive hostname
		      \item Ensure the system is fully updated
	      \end{itemize}

	\item \textbf{Install Active Directory Domain Services}
	      \begin{itemize}
		      \item Open Server Manager
		      \item Click ``Add roles and features''
		      \item Select ``Active Directory Domain Services'' role
		      \item Include management tools when prompted
		      \item Complete the installation wizard
	      \end{itemize}

	\item \textbf{Promote to Domain Controller}
	      \begin{itemize}
		      \item Click the notification flag in Server Manager
		      \item Select ``Promote this server to a domain controller''
		      \item Choose ``Add a new forest'' for a new domain or ``Add a domain controller to an existing domain''
		      \item Specify the root domain name (e.g., company.local)
		      \item Set the Forest and Domain functional levels (Windows Server 2016 or higher recommended)
		      \item Configure DNS and Global Catalog options (typically enabled by default)
		      \item Set Directory Services Restore Mode (DSRM) password
		      \item Review NetBIOS domain name
		      \item Specify paths for AD database, log files, and SYSVOL
		      \item Review settings and promote
		      \item Server will restart automatically
	      \end{itemize}

	\item \textbf{Post-Installation Configuration}
	      \begin{itemize}
		      \item Verify DNS is functioning correctly
		      \item Create Organizational Units (OUs) for logical organization
		      \item Configure Group Policy Objects (GPOs) as needed
		      \item Set up additional domain controllers for redundancy
		      \item Configure Active Directory Sites and Services if multi-site
		      \item Implement backup strategy for system state and Active Directory
		      \item Configure time synchronization (PDC Emulator should sync with external source)
		      \item Enable and configure Active Directory Recycle Bin for easier object recovery
	      \end{itemize}
\end{enumerate}

\subsection{Installation Steps - PowerShell}

\begin{enumerate}
	\item \textbf{Set Static IP Address}
	      \begin{lstlisting}[language=bash]
# View current network adapters
Get-NetAdapter

# Set static IP (adjust values for your environment)
New-NetIPAddress -InterfaceAlias "Ethernet" -IPAddress 10.0.1.10 -PrefixLength 24 -DefaultGateway 10.0.1.1

# Set DNS to localhost (127.0.0.1) and secondary
Set-DnsClientServerAddress -InterfaceAlias "Ethernet" -ServerAddresses 127.0.0.1,8.8.8.8
\end{lstlisting}

	\item \textbf{Rename Computer}
	      \begin{lstlisting}[language=bash]
# Rename the server
Rename-Computer -NewName "DC01" -Restart
\end{lstlisting}

	\item \textbf{Install AD DS Role}
	      \begin{lstlisting}[language=bash]
# Install Active Directory Domain Services role with management tools
Install-WindowsFeature -Name AD-Domain-Services -IncludeManagementTools

# Verify installation
Get-WindowsFeature | Where-Object {$_.Name -eq "AD-Domain-Services"}
\end{lstlisting}

	\item \textbf{Promote to Domain Controller (New Forest)}
	      \begin{lstlisting}[language=bash]
# Import the AD DS Deployment module
Import-Module ADDSDeployment

# Create new forest and promote to DC
Install-ADDSForest `
    -DomainName "company.local" `
    -DomainNetbiosName "COMPANY" `
    -ForestMode "WinThreshold" `
    -DomainMode "WinThreshold" `
    -InstallDns:$true `
    -CreateDnsDelegation:$false `
    -DatabasePath "C:\Windows\NTDS" `
    -LogPath "C:\Windows\NTDS" `
    -SysvolPath "C:\Windows\SYSVOL" `
    -NoRebootOnCompletion:$false `
    -Force:$true
\end{lstlisting}
	      \textit{Note: You'll be prompted for the SafeModeAdministratorPassword (DSRM password)}

	\item \textbf{Promote Additional Domain Controller (Existing Domain)}
	      \begin{lstlisting}[language=bash]
# Add DC to existing domain
Install-ADDSDomainController `
    -DomainName "company.local" `
    -InstallDns:$true `
    -Credential (Get-Credential "COMPANY\Administrator") `
    -DatabasePath "C:\Windows\NTDS" `
    -LogPath "C:\Windows\NTDS" `
    -SysvolPath "C:\Windows\SYSVOL" `
    -NoRebootOnCompletion:$false `
    -Force:$true
\end{lstlisting}

	\item \textbf{Post-Installation Verification}
	      \begin{lstlisting}[language=bash]
# Verify AD Web Services is running
Get-Service ADWS

# Check domain controller functionality
Get-ADDomainController

# Test AD replication (if multiple DCs)
repadmin /replsummary

# Verify DNS zones
Get-DnsServerZone

# Check SYSVOL replication
dfsrdiag replicationstate /all

# Verify FSMO roles
Get-ADDomain | Select-Object InfrastructureMaster, RIDMaster, PDCEmulator
Get-ADForest | Select-Object DomainNamingMaster, SchemaMaster
\end{lstlisting}

	\item \textbf{Create Organizational Units}
	      \begin{lstlisting}[language=bash]
# Create OUs for organization
New-ADOrganizationalUnit -Name "Users" -Path "DC=company,DC=local"
New-ADOrganizationalUnit -Name "Computers" -Path "DC=company,DC=local"
New-ADOrganizationalUnit -Name "Groups" -Path "DC=company,DC=local"
New-ADOrganizationalUnit -Name "Servers" -Path "DC=company,DC=local"
\end{lstlisting}

	\item \textbf{Configure Active Directory Recycle Bin}
	      \begin{lstlisting}[language=bash]
# Enable AD Recycle Bin (cannot be reversed)
Enable-ADOptionalFeature -Identity 'Recycle Bin Feature' `
    -Scope ForestOrConfigurationSet `
    -Target 'company.local' `
    -Confirm:$false
\end{lstlisting}

	\item \textbf{Configure Time Synchronization (PDC Emulator)}
	      \begin{lstlisting}[language=bash]
# Configure external time source on PDC Emulator
w32tm /config /manualpeerlist:"time.windows.com,0x8" /syncfromflags:manual /reliable:yes /update

# Restart Windows Time service
Restart-Service W32Time

# Force sync and check status
w32tm /resync
w32tm /query /status
\end{lstlisting}

	\item \textbf{Set Password Policy}
	      \begin{lstlisting}[language=bash]
# Configure default domain password policy
Set-ADDefaultDomainPasswordPolicy -Identity "company.local" `
    -ComplexityEnabled $true `
    -LockoutDuration "00:30:00" `
    -LockoutThreshold 5 `
    -MaxPasswordAge "90.00:00:00" `
    -MinPasswordAge "1.00:00:00" `
    -MinPasswordLength 12 `
    -PasswordHistoryCount 24
\end{lstlisting}
\end{enumerate}

\subsection{Security Best Practices}
\begin{itemize}
	\item Implement least privilege access for domain administrators
	\item Use separate administrative accounts for daily tasks vs. domain administration
	\item Enable and monitor security logs
	\item Regularly patch and update the domain controller
	\item Consider implementing tiered administrative model
	\item Use strong password policies and account lockout policies
	\item Utilize Advanced Threat Protection
\end{itemize}

\end{document}
